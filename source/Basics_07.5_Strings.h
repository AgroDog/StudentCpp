#pragma once

#include <iostream>
using namespace std;

namespace Strings
{
   /*
    * Строка - это обычный массив символов.
    * 
    * Но для удобства работы с таким массивом (вывод на экран, чтение, обработка)
    * строку снабдили особым признаком конца массива - нулевым байтом,
    * после байт такого массива равен нулю - это и есть признак конца строки.
    * 
    * Например, строка "Hi" в памяти занимает на самом деле 3 байта
    * 
    *    |------|------|------|
    *    |  72  |  105 |   0  |
    *    |------|------|------|
    *    
    * 72 - это код символа 'H' в таблице ASCII
    * 105 - это код символа 'i' в таблице ASCII
    * 0 - это признак конца строки
    * 
    * Т.к. в памяти все данные хранятся только в числовом виде, то все символы
    * кодируются через их коды. Таблицы кодировок бывают разными. Основные это
    * ASCII и Unicode. 
    * 
    * ASCII хранит символы в диапазоне от 0 до 255, поэтому содержит не так уж много
    * символов: латинский алфавит, цифры и некоторое кол-во спец.символов. Поэтому
    * для кодирования этой таблицы достаточно объема памяти в 1 байт. Это и есть
    * тип данных char.
    * 
    * Unicode же может кодировать символы 2, 4 или 8 байтами. Поэтому содержит огромное
    * кол-во символов. Все региональные алфавитные системы, включая арабские, иероглифичные,
    * греческие и т.д. и т.д.
    * 
    * char может работать с режиме нескольких байт
    * 
    * char c = 'ф';
    * 
    * сработается. В памяти будет храниться несколько байт для числа 444 (код символа 'ф'
    * по уникоду это '\u0444'). Если делать
    * 
    * cout << c; 
    * 
    * в последних версиях ОС Linux, то у вас даже все будет работать. А вот с Windows
    * могут быть сложности, потому что Windows имеет кодировку консоли не UTF-8 
    * (которая поддерживает все Unicode символы). Поэтому в Windows может понадобится
    * пошаманить с консолью, чтобы ввод-вывод сработал корректно.
    * 
    * Так или иначе наличие нулевого байта в конце строки позволяет 
    * во всех операциях со строками не контролировать длину массива
    * с помощью отдельной переменной (потому что С++ не следит за границами 
    * и целостностью массива), а однозначно находить конец массива без дополнительных
    * средств.
    * 
    * Если нулевого байта в конце строки не окажется (вдруг вы его случайно затерли
    * или забыли добавить при ручном формировании строки), то операция со строкой
    * продолжится до тех пор, пока в памяти не будет найден случайный нулевой байт.
    * Так что, если при операции со строкой у вас в конце стоят "кракозябры" - 
    * это верный признак, что у вас нет нулевого байта в конце строки.
    * 
    * Как и любой массив строка может быть статической
    * 
    * char phone[11];
    * 
    * или данимической
    * 
    * char* fio;
    * 
    * Правила тоже те же: если длина строки заранее известна и фиксирована, то
    * стоит использовать статическую строку.
    * 
    * Иначе нужно динамически выделять память под строку, а потом высвобождать ее.
    * 
    * Также не нужно хранить памяти под строку больше, чем потребуется. Основное правило:
    * 
    * определить сколько памяти требуется под строку, выделить необходимое кол-во этой памяти,
    * работать с этим объемом, когда он больше не нужен - высвободить.
    * 
    * Самая частая операция со строками - их копирование и чтение с экрана. Раз это такие
    * частые операции, то стоит выделить их в отдельные ф-ции для дальнейшего удобства
    * работы с ними.
    */

   // Ф-ция чтения строки с экрана
    char* readString()
    {
       /*
        * При чтении с экрана мы не можем знать, какую строку введет пользователь:
        * может быть, совсем короткую, но, может быть, и дофига длинную.
        * 
        * Поэтому для непосредственной операции чтения из потока консоли мы создадим
        * временную локальную переменную, так называемый буфер, цель существования которой
        * временное хранение данных, пока мы их обрабатываем должным образом.
        */

        char buf[255]; // Создаем буфер с "запасом", чтобы хватило
        cin.getline(buf, 255); // Читаем данные в него

        /*
         * Почему лучше использовать именно 
         * 
         * cin.getline(buf, 255);
         * 
         * а не просто 
         * 
         * cin >> buf;
         * 
         * так ведь проще. Проще, но небезопасно.
         * 
         * Мы выделили под buf 255 символов. Но всегда есть шанс, что пользователь захочет
         * напечатать "Войну и мир" в поле ввода и тогда он превысит лимит в 255 символов.
         * 
         * Если мы используем cin >> buf, и введенных символов будет больше 255, то запись
         * данных продолжится несмотря на конец зарезервированной области данных. А значит
         * вы испортите данные идущие сразу после зарезервированной области. В итоге рано
         * или поздно у вас будет ошибка повреждения кучи - heap corruption.
         * 
         * Поэтому ф-ция cin.getline(dest, number) принимает 2 параметра:
         * dest - куда записывать данные из потока
         * number - кол-во символов для считывания
         * 
         * Даже если пользователь введет больше символов, чем number, то все лишние
         * символы будут отброжены и проигнорированы. И повреждения кучи уже не будет.
         * 
         * При чтении с экрана строки с помощью ли cin >> или cin.getline, когда пользователь
         * нажмет Enter в конец потока будет добавлен нулевой байт, как символ окончания ввода.
         */

       /*
        * Теперь нам нужно определить сколько же "полезных" символов ввел пользователь.
        * buf имеет размер 255 символов, но пользователь мог ввести всего 5, 10 
        * или вообще 0 символов. Поэтому таскать по программе за собой все 255 байт
        * в памяти неэффективно.
        * 
        * Определить длину массива символов может ф-цию strlen (string length), которая
        * принимает как параметр указатель на начало строки.
        * 
        * Работает эта ф-ция очень просто: она идет по массиву до тех пор, пока не встретит
        * нулевой байт. И возвращает полученное число символов.
        * 
        * После определения реальной длины строки мы уже знаем, сколько байт памяти нужно выделить
        * под нашу строку.
        */
        char* str = new char[strlen(buf)]; // Выделяем ровно столько памяти, сколько "полезных" символов в буфере

        /*
         * Теперь у нас есть буфер с данными и пустой массив str нужной длины. И нам нужно скопировать
         * данные их буфера в итоговую строку. Для этого есть ф-ция strcpy, которая такжк как и любая
         * строковая ф-ция работает до нулевого байта.
         */

        strcpy(str, buf); // Копируем реальную строку из буфера в переменную str
        
         /*
         * После завершения ф-ции чтения строки с экрана временный буфер buf как локальная переменная
         * будет уничтожен и его память освободится, указатель str - тоже локальная переменная и тоже будет
         * уничтожен, а вот выделенная под строку память в куче останется жить дальше.
         *
         * Именно для того, чтобы не потерять доступ до этой памяти, мы возвращаем адрес этой памяти
         * как результат выполнения ф-ции чтения строки с экрана.
         */
       
         return str;
    }

    int main()
    {
       // Т.к. строка является обычным массивом, то и работать с ней можно просто как с массивом
        char str0[7] = "qwerty";
        cout << str0 << endl;
        str0[6] = '!';
        cout << str0 << endl;

       // Конечно, если мы знаем длину строки и она фиксирована читать с экрана можно в упрощенном режиме
        char str1[5];
        cout << "Введите строку str1: ";
        cin.getline(str1, 5);
        cout << str1 << endl;

        // Но вообще обычно это выглядит именно так:
        char* buf = new char[255]; // Создаем буфер с "запасом", чтобы хватило
        cout << "Введите строку str2: ";
        cin.getline(buf, 255); // Читаем данные в него
        char* str2 = new char[strlen(buf)]; // Выделяем ровно столько памяти, сколько "полезных" символов в буфере
        // strlen - ф-ция определения длины строки. Она считает символы только до нулевого байта
        // Если пользователь ввел всего 10 символов, то strlen и вернет 10
        strcpy(str2, buf); // Копируем реальную строку из буфера в переменную str2
        delete[] buf; // Удаляем ненужный больше буфер
        cout << str2 << endl;

       // Однако писать столько строк кода для каждого чтения с экрана строки - муторно,
       // именно поэтому мы уже создали ф-цию чтения строки с экрана, чтобы облегчить эту работу

        cout << "Введите строку str3: ";
        char* str3 = readString();
        cout << str3 << endl;

        return 0;
    }
}