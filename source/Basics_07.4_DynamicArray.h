// Рассматриваемые темы:
// Динамический массив

#pragma once
#include <iostream>
using namespace std;

namespace DynamicArray
{
   void main()
   {
      /*
      * Итак, со статическими массивами разобрались. 
      * Теперь пора перейти к динамическим.
      * 
      * Основное и краеугольное отличие статических и динамических массив
      * в том, где каждый из них хранится.
      * 
      * Статический - в стеке,
      * Динамический - в куче.
      * 
      * Жизненным циклов статического управляет программа, динамическим сам программист.
      * 
      * Суть динамического массива в том, что программист сам, как хочет управляет памятью.
      * Это дает безграничную гибкость в написании кода, но и безграничные возможности
      * выстрелить себе в ногу... Sad, but true.
      * 
      * Раз абсолютно все находится в ведении программиста, то даже выделять, высвобождать
      * и следить за целостностью данных (их сохранностью) должны мы сами.
      * 
      * Есть две основные команды по работе с динамической памятью (кучей):
      * 1. выделить память
      * 2. высвободить память
      */

      /*
       * 1. Выделение памяти
       * Для выделения памяти есть оператор new.
       * 
       * Оператор new резервирует память под хранение данных. Не трудно догадаться, что память
       * в компьютере либо есть, либо ее нет. Поэтому сказать, что new "создает" память - неверно,
       * он же не добавит вам новые планки оперативной память (а жаль, было бы круто). Память
       * была еще до new. Более того, память под использование программой выделяется операционной
       * системой в момент запуска программы: программа точно знает "куда можно ходить" ну или
       * какую память можно, а какую нельзя использовать.
       * 
       * Т.е. память у программы есть. Но на "общая" для всей программы. Переменные все время создаются,
       * программа потребляет это пространство памяти для своей жизнедеятельности, причем какие-то
       * процессы мы не можем контролировать.
       * 
       * Куча - это свалка памяти, ею пользуются все процессы в вашей программе. Ячейки все время
       * используются кем-то или чем-то. Чем больше и сложнее программа, тем хаотичнее и чаще 
       * ячейки кучи задействуются.
       * 
       * Скажите, вам понравится, если вы сохраните какие-то данные по адресу в куче, а потом
       * программа без вашего ведома возьмет и поменяет эти данные? Что получится в итоге непредсказуемо,
       * а значит опасно.
       * 
       * Чтобы такого не происходило, компиляторами продуман механизм "резервирования" памяти.
       * 
       * При резервировании памяти некоторые ячейки помечаются "занятыми" для использования вами.
       * Такие зарезервированные ячейки программа без вас, сама трогать не будет, теперь эти ячейки
       * можете изменить только вы своими шаловливыми ручонками.
       * 
       * Вот что делает оператор new. Он резервирует определенный объем памяти в куче.
       * 
       * Кстати, кстати.
       * 
       * Оператор new это опять же синтаксический "сахар". На самом деле он внутри своей реализации
       * вызывает ф-цию выделения памяти malloc(size_to_allocate);
       * 
       * malloc расшифровывается как memory allocate
       * memory - память
       * allocate - выделить, зарезервировать
       * 
       * В качестве параметра malloc принимает кол-во байт, которое нужно выделить.
       * 
       * new float;
       * 
       * преобразуется компиляторов в 
       * 
       * malloc( sizeof(float) );
       * 
       * А как же работает оператор new и ф-ция malloc? Как она находит место, где можно зарезервировать память.
       * Очень просто. Поиск начинается с адреса начала кучи, находится НЕПРЕРЫВНЫЙ и свободный участок в памяти,
       * и уже он резервируется.
       * 
       * С++ тупой, поэтому работает так. Это на самом деле не очень оптимально. Но вот такой это простой язык.
       * Ядыки с виртуальными машинами типа c# и java работают с памятью по более сложным алгоритмам.
       */

      float* ptr1 = new float; // зарезервировали sizeof(float) байт памяти в куче
      *ptr1 = 1.5;
      cout << "*ptr1 = " << *ptr1 << endl;

      /*
       * Итак, что тут произошло.
       * 
       * Мы создали указатель. Затем с помощью оператора new выделили память под ячейку памяти
       * типа данных float (4 или сколько там байт - всегда можно запустить sizeof(float),
       * чтобы узнать точно). И адрес выделенной памяти сохранился в указатель ptr1.
       * 
       * Что важно:
       * 
       * ptr1 - это локальная переменная и будет храниться в стеке
       * оператор new - выделил память в куче, не в стеке
       * 
       * 
       *        СТЕК           |            КУЧА
       *                       |
       *    0xFFFC2, ptr1      |           0xFAA01
       *    |-----------|      |         |---------|
       *    |  0xFAA01  |      |         |   1.5   |
       *    |-----------|      |         |---------|
       *    
       *  Как любая локальная переменная ptr1 будет уничтожена, когда завершится ее блок кода.
       *  А вот память в куче... Нет. Потому что вся ответственность за нее лежит на программисте.
       *  Как хочешь так и разбирайся.
       *  
       *  Выглядеть это будет так.
       *  
       *        СТЕК           |            КУЧА
       *                       |
       *                       |           0xFAA01
       *                       |         |---------|
       *                       |         |   1.5   |
       *                       |         |---------|
       *                       
       * Стек избавился от своей переменной ptr1, а вот зарезервированная область в памяти так и осталась
       * зарезервированной. Программа не может использовать эту память повторно.
       * 
       * Да и мы больше не имеем доступа до этой памяти. Мы же потеряли адрес, где это память хранится.
       * 
       * Конечно, после завершения программы, вся память выделенная программе ОС, в том числе и куча,
       * будет высвобождена, очищена и пожертвована другому процессу в ОС. Но вы правда хотите, чтобы
       * ваша программа оставляла за собой неиспользуемый мусор, засоряла память и т.д.?
       * 
       * Вам нравится, когда программы жрут по 1Гб, 2Гб, 3Гб памяти причем непонятно зачем, когда они
       * ничего такого мега сложного не делают? Конечно, не нравится. Поэтому не надо мусорить там,
       * где вы работаете, т.е. в памяти вашей программы.
       */

      /*
       * 2. Высвобождение памяти
       * 
       * Чтобы иметь возможно подчищать за собой больше ненужную нам память в куче был введен
       * оператор delete.
       * 
       * delete в качестве параметра принимает указатель (читай, адрес) на ту область памяти,
       * которую нужно высвободить.
       * 
       * Кстати, delete также как и new на самом деле запускает ф-цию высвобождения памяти free,
       * которая как параметр принимает указатель.
       * 
       * delete pointer;
       * 
       * эквивалентно
       * 
       * free(pointer);
       * 
       * Правило обращения с динамической памятью достаточно простое:
       * Каждому new даешь свой delete. Написали где-то new? Значит, нужно где-то эту память высвободить. Никак иначе.
       * 
       * Ок, если мы передаем указатель, то это адрес всего лишь 1 байта в памяти, но даже
       * выше мы зарезервировали память под float, а это всяко больше 1 байта!
       * 
       * Получается, освободится только 1 байт? А потом нам в цикле нужно бегать и высвобождать
       * все остальные ячейки?
       * 
       * Без паники. Разработчики компилятора о вас уже позаботились.
       * 
       * <информация_для_продвинутых>
       * 
       * На самом деле при резервировании памяти, вам для использования выдается указатель
       * не на первую зарезервированную ячейку, а на следующую... Потому что в самой первой ячейке
       * хранится так называемые метаданные о памяти. В этих метаданных хранится объем выделенной памяти,
       * тип данных, под который изначально память выделялась и некоторая еще информация.
       * 
       *      0xFAA00   0xFAA01   0xFAA02   0xFAA03   0xFAA04 
       *    |----------|---------|---------|---------|---------|
       *    |метаданные|    x    |    x    |    x    |    x    |
       *    |----------|---------|---------|---------|---------|
       *                    ^
       *                    |
       *           вы получите на руки
       *            адрес этой ячейки
       *    
       * Кстати, метаданные могут занимать не 1 байт памяти, но это значение всегда фиксировано у компилятора,
       * он знает сколько метаданных ему нужно для работы. Но для простоты сейчас используется, что
       * метаданные занимают 1 байт памяти.
       * 
       * Поэтому когда вы параметром в delete передаете указатель, программа сначала делает шаг назад,
       * считывает из метаданных нужную информацию об объеме выделенной памяти и высвободит 
       * все 4 или сколько там было ячеек.
       * 
       * </информация_для_продвинутых>
       * 
       * Так что на самом деле компилятор хранит информацию о том, под какой тип данных была
       * зарезервирована память и соответственно при освобождении он увидит, сколько памяти
       * начиная с данного адреса была выделено, и сколько сейчас нужно высвободить.
       */

      delete ptr1;

      /*
       * После высвобождения памяти, флаг "занято" с памяти снимается.
       * Соответственно, если мы попытаемся обратиться к такой памяти еще раз,
       * уже после ее освобождения, программа вывалится в ужасе с ошибкой
       * "Access violation", что в вольном переводе означает "у меня нет прав сюда лезть".
       * 
       * Но скажем так, С++ далеко не всегда настолько усожлив, чтобы сообщить нам,
       * что мы полезли куда-то не туда. Обычно предупреждающей таблички нет,
       * мы залезаем на чужую территорию и кто-нибудь потом, когда мы уже не ждем
       * стреляет нам в ногу... Или голову в зависимости от критичности ошибки в коде.
       */

      // cout << "*ptr1 = " << *ptr1 << endl; // Тут будет ошибка времени исполнения

      /*
       * Ладно, ладно. Мы немного отвлеклись, но это было необходимо.
       * 
       * Раз динамические массивы хранятся в куче, то память под них выделять и высвобождать
       * будем мы сами, ручками. Ну а что вы хотели. -_- Жизнь жестока.
       */

      int* array1 = new int[5];

      /*
       * Итак, начнем разбирать с самого легкого. Правая половина выражения.
       * 
       * new int[5];
       * 
       * Это синтаксис выделения памяти под массив, элеметами которого являются int
       * и таких чисел 5 штук.
       * 
       * Через malloc записывается так:
       * 
       * malloc( sizeof(int) * 5 );
       * 
       * Таким образом выделится 20 байт памяти.
       * 
       * Как и положено после резервирования памяти, оператор new вернет как результат
       * указатель на НАЧАЛО выделенной области памяти.
       * 
       * Все то же самое было и со статическими массивами, там тоже имя массива являлось
       * адресом начала массива. Только хранился он в стеке, а тут в куче.
       * 
       * Короче, вернулся нам адрес первого элемента в массиве, он же начало всего массива.
       * 
       * Поэтому тип данных указателя должен быть int. Потому что элемент, адрес на который
       * нам вернулся именно что int.
       * 
       * Так что слева нам и пришлось написать 
       * 
       * int* array1 - указатель на тип данных int.
       * 
       * Ну а в памяти все это безобразие выглядеть будет так:
       * 
       *        СТЕК           |            КУЧА
       *                       |
       *    0xFFFC2, array1    |           0xFAA01   0xFAA02   0xFAA03   0xFAA04   0xFAA05
       *    |-----------|      |         |---------|---------|---------|---------|---------|
       *    |  0xFAA01  |      |         |   xxx   |   xxx   |   xxx   |   xxx   |   xxx   |
       *    |-----------|      |         |---------|---------|---------|---------|---------|
       *                                      0         1         2         3         4
       *                                      ^
       *                                      |
       *                                    array1
       *                                      
       */

      // В плане работы с массивом нет никакой разницы ни по синтаксису, ни по логике
      // по сравнению со статическим массивом
      array1[0] = 11;
      array1[1] = 12;
      array1[2] = 13;
      array1[3] = 14;
      array1[4] = 15;

      for (int i = 0; i < 5; i++) cout << "array1[" << i << "] = " << array1[i] << " ";

      // Не забываем высвободить память
      int* ptr = array1;
      delete[] array1;

      /*
       * "Что за фигня?" спросите вы, увидев delete[], "зачем у delete написан оператор []"
       * 
       * Если кратко, то delete[] должен быть вызван, если выделение памяти было через new[],
       * в частности для массивов.
       * 
       * delete соответственно вызывается, если память выделялась с помощью new.
       * 
       * Сейчас придется вам поверить мне на слово: 
       * 
       * Для массивов из простых типов данных, вы не почувствуете разницу между delete и delete[],
       * работать при удалении массива они будут одинаково. Но вот дальше, когда будут изучаться
       * пользовательские типы данных, классы, там путаница с delete и delete[] может вызвать
       * ошибки времени исполнения и повреждение памяти.
       * 
       * Привыкайте правильно пользоваться операторами. Если память была выделена под массив,
       * то и высвобождать эту память нужно как для массива.
       * 
       * Пример, когда вызов delete для массива объектов повредит память будет в разделе 
       * "жизненный цикл объектов"
       */
   }
}