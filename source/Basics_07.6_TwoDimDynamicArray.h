// Рассматриваемые темы:
// Ступенчатые массивы

#pragma once
#include <iostream>
using namespace std;

namespace TwoDimDynamicArray
{
   void main()
   {
      /*
      * С многомерными массивами все немного сложнее, чем было у статических массивов.
      *
      * Дело в том, что 
      * 
      * int[2][3];
      * 
      * запись (оператор [][], использовавшийся раньше для создания двумерных массивов)
      * применим при создании массива только для статических массив.
      * 
      * Потому что в этом случае данные будут выделены подряд, а это значит, что
      * "расширить" кол-во данных будет нельзя. Возьмем наш старый пример со студентами
      * и их оценками.
      * 
      *       0      1      2      3      4      5
      *    |------|------|------|------|------|------|
      *    |  5   |  5   |  2   |  2   |  4   |  3   |
      *    |------|------|------|------|------|------|
      *    ^             ^             ^             ^
      *    |-------------|-------------|-------------|
      *     оценки 1 ст.   оценки 2 ст.  оценки 3 ст.
      *     
      * Первостепенная причина динамической памяти - это гибкость работы с ней.
      * Для массивов это означает изменение размеров в любой момент выполнения программы.
      * 
      * Но если данные хранятся единым блоком, как на рисунке выше, а нам в процессе 
      * выполнения программы понадобилось увеличить кол-во дисциплин, по которым хранятся
      * оценки. Сейчас мы храним 2 оценки у студента, но что будет, если внезапно понадобилось
      * расширить до 4?
      * 
      *       0      1      2      3      4      5
      *    |------|------|------|------|------|------|
      *    |  5   |  5   |  2   |  2   |  4   |  3   |
      *    |------|------|------|------|------|------|
      *    ^             ^             ^             ^
      *    |-------------|-------------|-------------|
      *     оценки 1 ст.   оценки 2 ст.  оценки 3 ст.
      *                  ^
      *                  |
      *          по идее куда-то сюжа
      *          нужно вставить 3 и 4
      *          оценку для 1 студента
      *  
      *  Но мы не можем в эту точку добавить никаких данных, потому что дальше находятся
      *  оценки уже второго студента. Вынести эти данные в какое-то другое место тоже нельзя,
      *  потому что основа массива - это хранение данных подряд.
      *  
      *  "Сжать" данные тоже не получится. Если кол-во оценок уменьшится с 2 до 1, то
      *  получатся "дырки" в массиве.
      *     
      *       0             1             2       
      *    |------|      |------|      |------|       
      *    |  5   |      |  2   |      |  4   |       
      *    |------|      |------|      |------|       
      *    ^             ^             ^             ^
      *    |-------------|-------------|-------------|
      *     оценки 1 ст.   оценки 2 ст.  оценки 3 ст.
      *     
      * Опять же нарушение принципов массива!
      *  
      * Ну никак в этой ситуации "динамичности" у нас не получится.
      *
      * Поэтому для многомерных динамических массив применяют другой подход,
      * создают так называемый массив массив.
      * 
      * Если раньше двумерный массив был по сути одним большим массивом с удобным
      * доступом до элементов, то теперь мы создадим несколько массивов связанных
      * между способ с помощью косвенной адресации - указателей.
      * 
      * Рассматривать будем на двумерном массиве студентов. 3 студента с 2 оценками каждый.
      * 
      * Массив массивов. По логике фразы становится понятно, что каждый элемент массива
      * будет являться другим массивом. Брррррр -____________- Как же это сделать?
      * 
      * Не можем же мы в ячейку памяти впихнуть "массив". Ячейка хранит всего одно значение.
      * 
      * Все так. Только чем является имя массива в с++? Указателем на начало массива. Т.е. адресом.
      * 
      * Мы можем создать массив адресов на другие массивы? Да легко. Это будет массив указателей.
      * 
      * Создадим его.
      */

      int** array2 = new int*[3];

      /*
       * Этот массив представляет собой массив "студентов". У каждого студента будет свой массив оценок.
       * 
       * int* * array2 = new int* [3];
       * ^^^  ^              ^^^
       *  |   |               |
       *  |   |             Мы выделяем память под указатели,
       *  |   |             поэтому и написали тип данных - указатель
       *  |   |
       *  |   Эта звездочка нужна,
       *  |   потому что new вернет
       *  |   указатель на начало
       *  |   зарезервированной памяти
       *  |
       *  |
       *  |
       * Это тип данных
       * элемента, который
       * находится по адресу
       * указателя. У нас там 
       * будут указатели,
       * адреса начала массивов
       * с оценками
       * 
       * 
       * 
       * Т.е. каждый элемент array2 будет адресом на начало массива с оценками - целыми числами.
       * Выделим память под такой массив для каждого студента.
       * 
       * А имя такого массива с указателями соответственно указатель на указатель. 
       * Две звездочки в типе данных свидетельствует об этом.
       * Одна показывается, что по адресу будет находиться указатель,
       * вторая - что эта переменная и сама указатель.
       * 
       * Мы получили в памяти что-то такое:
       * 
       *                     КУЧА                                       СТЕК
       * 
       *          ---------------------------------------------------------
       *          |                                                       |
       *                                                                  |
       *       0xFFF01     0xFFF02     0xFFF03                            |
       *          0           1           2                             array2
       *    |-----------|-----------|-----------|                   |-----------|
       *    |  xxxxxxx  |  xxxxxxx  |  xxxxxxx  |                   |  0xFFF01  |
       *    |-----------|-----------|-----------|                   |-----------|
       *          ^           ^           ^
       *          |           |           |
       *     тут будет    тут будет    тут будет
       *     адрес масс   адрес масс   адрес масс  
       *     с ценками    с ценками    с ценками
       *     студента 1   студента 2   студента 3
       *     
       *     
       * Причем помните, что указатель array2 хранится в стеке. А вот выделенная память
       * под массив указателей хранится в куче!
       * 
       * Теперь нужно выделить память под массивы оценок каждого студента.
       * 
       * Сделать это проще всего в цикле. Потому что в цикле потом константу 3 - кол-во
       * студентов можно заменить на переменную n - кол-во студентов. А вот при ручном 
       * объявлении такого уже не сделаешь.
       */

      for (int i = 0; i < 3; i++)
         array2[i] = new int[2]; // Выделили память под массив с двумя оценками

      /*
       * Теперь вся эта жуть в памяти выглядит так:
       *                     КУЧА                                       СТЕК
       * 
       *          ---------------------------------------------------------
       *          |                                                       |
       *                                                                  |
       *       0xFFF01     0xFFF02     0xFFF03                            |
       *          0           1           2                             array2
       *    |-----------|-----------|-----------|                   |-----------|
       *    |  0xFFA45  |  0xFAC34  |  0xFBB11  |                   |  0xFFF01  |
       *    |-----------|-----------|-----------|                   |-----------|
       *          |           |           |
       *          |           |           |
       *       ----           ---------   ------------------------
       *       |                      |                          |
       *     |---|---|              |---|---|                  |---|---|    
       *     | x | x |              | x | x |                  | x | x |    
       *     |---|---|              |---|---|                  |---|---|    
       *      0xFFA45                0xFAC34                    0xFBB11
       *      
       * Как видно на иллюстрации массивы расположены абсолютно хаотично друг относительно друга.
       * Где уже new нашел подходящее место под массив - там его и приткнул.
       * 
       * Связаны же между собой массивы оценок через массив указателей, который хранит все их адреса.
       * Нам же для управления всем этим хозяйством дан указатель array2, который хранит
       * адрес начала массива массивов...
       * 
       * Да, вот такое вот оно неприглядное. Но если разобраться и вникнуть один раз, то
       * становится все не таким уж и сложным. Но один раз поломать голову придется.
       */

      /*
       * А вот пользоваться динамическим массивом можно уже также, как и статическим,
       * разницы уже никакой.
       */

      for (int i = 0; i < 3; i++)
         for (int j = 0; j < 2; j++)
            array2[i][j] = i+j; // Ну да, оценки не по 5-ти бальной шкале. И че???
      
      /*
       * Время упоротости! Как записать доступ до элемента динамического двумерного массива
       * без использования оператора [][]? ^_^
       * 
       * Допустим, мы хотим получить 
       * 
       * array2[2][1];
       * 
       * Если смотреть на схемку памяти выше, то все становится даже проще, чем
       * со статическим массивом.
       * 
       *                     КУЧА                                       СТЕК
       * 
       *          ---------------------------------------------------------
       *          |                 нужный студент                        |          
       *          |                       |                               |
       *                                  |                               |
       *       0xFFF01     0xFFF02     0xFFF03                            |
       *          0           1           2                             array2
       *    |-----------|-----------|-----------|                   |-----------|
       *    |  0xFFA45  |  0xFAC34  |  0xFBB11  |                   |  0xFFF01  |
       *    |-----------|-----------|-----------|                   |-----------|
       *          |           |           |
       *          |           |           |
       *       ----           ---------   ------------------------
       *       |                      |                          |
       *     |---|---|              |---|---|                  |---|---|     
       *     | 0 | 1 |              | 1 | 2 |                  | 2 | 3 |     
       *     |---|---|              |---|---|                  |---|---|    
       *      0xFFA45                0xFAC34                    0xFBB11
       *                                                             ^
       *                                                             |
       *                                                       нужная оценка
       *      
       * array2 - это адрес начала массива с указателями. Нам нужен элемент со смещением 2
       * (потому что индекс 2 - а это и есть смещение - кто не понял идет и еще раз читает
       * про динамические массивы или массивы в целом).
       * 
       * array2 + 2 - адрес ячейки в массиве указателей, адрес ячейки с адресом массива оценок нужного студента
       * 0xFFF01 + 2 = 0xFFF03
       * 
       * *(array2 + 2) - получили адрес массива оценок нужного студента
       * *(0xFFF03) = 0xFBB11
       * 
       * Теперь у нас есть адрес начала массива с оценками студента. Теперь в этом массиве нам нужна
       * оценка со смещением 1 относительно начала массива.
       * 
       * 0xFBB11 + 1 = 0xFBB12- адрес ячейки с оценкой
       * *(0xFBB12) = 3
       * 
       * А теперь избавимся от частностей, адресов и индексов, и запишем все голой формулой:
       * 
       * *( (*array2 + i) + j )
       * 
       * где i - индекс студента, j - индекс оценки
       */
      
      /*
       * УУУУУУУУУФФФФФФФФФФФФФ
       * 
       * Надеюсь, теперь всем понятно устройство двумерных динамических массивов.
       * Многомерные делаются по аналогии, просто кол-во уровней с массивами указателей увеличивается.
       * 
       * Там, где у нас был массив с оценками, тоже будет массив с указателями на начало массива с оценками
       * 
       * Если взять трехмерный массив:
       * 
       * 4 группы по 3 студента с 2 оценками, 
       * 
       * то у нас будет массив на 4 элемента указателей на массив с указателями на массив с оценками.
       */

      int*** array3 = new int**[4];
      for (int i = 0; i < 4; i++)
         array3[i] = new int*[3];

      for (int i = 0; i < 4; i++)
         for (int j = 0; j < 3; j++)
            array3[i][j] = new int[2];

      for (int i = 0; i < 4; i++)
         for (int j = 0; j < 3; j++)
            for(int k = 0; k < 2; k++)
               array3[i][j][k] = 5; // Все студенты - отличники. Ах...

      /*
       * На этом с темой массивов - все.
       * 
       * Можете идти и остудить голову в раковине. А то сейчас взорвется. ^_^
       */
   }
}