// Рассматриваемые темы:
// Конструктор копирования

// Внимание: идут постоянные отсылки к теме "Передача параметров по значению и ссыле"
// Убедитесь, что хорошо усвоили эту тему

#pragma once

#include <iostream>
#include <fstream>
#include <cstdlib>
#include <cstdio>
#include <string.h>

using namespace std;

namespace ClassCopyConstructor
{
   /*
    * Мы уже множество раз рассматривали ситуации, что переменные копируются в памяти
    * без нашего участия. Например, при передаче и возврате параметров в/из ф-ции.
    * Все примеры, которые разбирались в той теме, были построены на простейших типах данных:
    * int, float и т.д. При побайтовом копировании (а именно так программа копирует все данные
    *  - побайтого) никаких проблем с простыми типами данных возникнуть не может.
    *  
    *  Но что если параметром при передаче по значени будет объект? "Ну и что," - скажете вы, - 
    *  "Пусть себе также копируется побайтово. В чем проблема?" А сейчас посмотрим на примере,
    *  в чем же будет проблема.
    *  
    *  Создам простейший класс, Студент.
    */

   class StudentDummy
   {
      char* fio = nullptr;
   public:
      StudentDummy(const char* fio)
      {
         setFio(fio);
      }
      ~StudentDummy()
      {
         delete[] fio;
      }
      void setFio(const char* fio)
      {
         if (this->fio != nullptr) 
            delete[] this->fio;
         this->fio = new char[strlen(fio)+1];
         strcpy(this->fio, fio);
      }
      const char* getFio()
      {
         return fio;
      }
   };

   /*
    * Элементарный класс, всего лишь с одним полем. Конструктор как параметр принимает
    * константную строку, в которой будет записано ФИО студента. Под это ФИО выделяется
    * память в объекте и туда копируются данные. Все просто и знакомо.
    * 
    * В чем подвох?
    * 
    * А теперь создадим ф-цию, которая как параметр принимает студента и меняет его ФИО.
    */

   void func(StudentDummy student)
   {
      student.setFio("another fio");
   }

   /*
    * И что? Ведь параметр в ф-ции передан по значению. В памяти создалась копия,
    * работаем мы с копией, ФИО поменялось у копии. После завершения ф-ции копия
    * уничтожилась, а исходные данные остались без изменений. В чем проблема?
    * 
    * Допустим, вызов ф-ции был такой:
    * Student st("Ivanov Ivan Ivanovich");
    * func(st);
    * 
    * Давайте посмотрим на состояние памяти до и после вызова ф-ции.
    * 
    * До вызова ф-ции был создан студент, в конструкторе выделяется память
    * под fio, туда записывается ФИО и указатель сохраняется в классе.
    * 
    *                 st
    *    |--------------------------|
    *    |    |-----------------|   |
    *    |    |  fio = 0xFFFA1  |   |
    *    |    |-----------------|   |
    *    |--------------------------|
    *                 |
    *      ------------
    *      |
    *    0xFFFA1
    *    |---|---|---|---|---|---|---|---|---|---|---| ...
    *    | I | v | a | n | o | v |   | I | v | a | n | ...
    *    |---|---|---|---|---|---|---|---|---|---|---| ...
    *    
    * Что же произойдет при вызове ф-ции.
    * 
    * Во-первых, создастся копия студента, потому что параметр передается по значению.
    * Копирование будет побайтовое. А значит память будет в таком состоянии:
    * 
    * 
    *                 st                                student
    *    |--------------------------|        |--------------------------|
    *    |    |-----------------|   |        |    |-----------------|   |
    *    |    |  fio = 0xFFFA1  |   |        |    |  fio = 0xFFFA1  |   |
    *    |    |-----------------|   |        |    |-----------------|   |
    *    |--------------------------|        |--------------------------|
    *                 |                                    |
    *      ------------                                    |
    *      |------------------------------------------------
    *    0xFFFA1
    *    |---|---|---|---|---|---|---|---|---|---|---| ...
    *    | I | v | a | n | o | v |   | I | v | a | n | ...
    *    |---|---|---|---|---|---|---|---|---|---|---| ...
    *    
    * Побайтово скопировался студент. В студенте внутри хранится только указатель на область
    * в памяти с символами ФИО. Копия содержит только адрес данных, но не сами данные.
    * 
    * И адрес оказался тот же, что у оригинала. А вот сами данные в памяти как были одни,
    * так и остались. И получается, что один и тот же указатель разделили 2 объекта...
    * 
    * А внутри ф-ции мы меняем ФИО у копии. Если заглянуть внутрь метода setFio, то мы увидим
    * такой код:
    * 
    * if (this->fio != nullptr) 
    *    delete[] this->fio;
    * this->fio = new char[strlen(fio)+1];
    * strcpy(this->fio, fio);
    * 
    * Этот код удалит память по старому адресу, выделит новую память и сохранит новый 
    * адрес в поле fio.
    * 
    * И вот что получится после выполнения всей ф-ции func:
    * 
    *                 st                                student
    *    |--------------------------|        |--------------------------|
    *    |    |-----------------|   |        |    |-----------------|   |
    *    |    |  fio = 0xFFFA1  |   |        |    |  fio = 0xFFFBF  |   |
    *    |    |-----------------|   |        |    |-----------------|   |
    *    |--------------------------|        |--------------------------|
    *                 |                                    |
    *      ------------                                    |
    *      |                                               |
    *    0xFFFA1                                           |
    *    |---|---|---|---|---|---|---|---|---|---|---| ... |
    *    | x | x | x | x | x | x | x | x | x | x | x | ... |
    *    |---|---|---|---|---|---|---|---|---|---|---| ... |
    *                                                      |
    *      -------------------------------------------------
    *      |
    *    0xFFFBF
    *    |---|---|---|---|---|---|---|---|---|---|---|
    *    | a | n | o | t | h | e | r |   | f | i | o |
    *    |---|---|---|---|---|---|---|---|---|---|---|
    *    
    * Память по адресу 0xFFFA1 была высвобождена в худшем случае (чаще всего)
    * еще и "затерта" мусором. В копию student в поле fio был сохранен адрес
    * нововыделенной памяти, в которую и записана новая строка "another fio".
    * 
    * Ф-ция func завершилась. Копия student уничтожается, но память уже безвозвратно испорчена.
    * 
    *                 st
    *    |--------------------------|
    *    |    |-----------------|   |
    *    |    |  fio = 0xFFFA1  |   |
    *    |    |-----------------|   |
    *    |--------------------------|
    *                 |
    *      ------------
    *      |
    *    0xFFFA1                                          
    *    |---|---|---|---|---|---|---|---|---|---|---| ...
    *    | x | x | x | x | x | x | x | x | x | x | x | ...
    *    |---|---|---|---|---|---|---|---|---|---|---| ...
    *    
    * С такой ситуацией нельзя мириться и нельзя ее допускать.
    * 
    * Главная проблема состояла в том, что копирование объекта при передаче по значению
    * идет неправильно. Побайтовая копия в данном случае нам не подойдет. В данной ситуации
    * недостаточно было скопировать указатель в поле класса. Нужно было и создать копия данных
    * в куче, а указатель в копии объекта должен быть хранить адрес этой скопированной
    * области памяти.
    * 
    * Значит, достаточно часто, как минимум когда в классе имеются динамические данные,
    * копировать объект  нужно по особым правилам, которые можем предусмотреть только мы, 
    * создатели класса, потому что только мы на основе хранимых данных можем предусмотреть, 
    * как правильно нужно скопировать данные.
    * 
    * Для таких целей был придуман конструктор копирования.
    */

   /*
    * Конструктор копирования вызывается всегда, когда объект должен быть скопирован.
    * 
    * Такой конструктор имеет строгий фиксированный синтаксис - как параметр он принимает
    * ссылку на объект того же типа данных, что и сам класс.
    */

   class Student
   {
      char* fio = nullptr;
   public:
      Student(const char* fio)
      {
         setFio(fio);
      }
      Student(Student& anotherStudent) // Это и есть конструктор копирования
      {
         cout << "Copy constructor called" << endl;
         setFio(anotherStudent.getFio()); // Здесь мы выделим новую память под fio и скопируем туда данные
      }
      ~Student()
      {
         delete[] fio;
      }
      void setFio(const char* fio)
      {
         if (this->fio != nullptr)
            delete[] this->fio;
         this->fio = new char[strlen(fio) + 1];
         strcpy(this->fio, fio);
      }
      const char* getFio()
      {
         return fio;
      }
   };

   void func(Student student)
   {
      student.setFio("another fio");
   }

   /*
    * Итак теперь при вызове
    * 
    * Student good("Ivanov Ivan Ivanovich");
    * func(good);
    * 
    * память будет выглядеть совсем по-другому
    * 
    *                 good                             student
    *    |--------------------------|        |--------------------------|
    *    |    |-----------------|   |        |    |-----------------|   |
    *    |    |  fio = 0xFFFA2  |   |        |    |  fio = 0xFFFC5  |   |
    *    |    |-----------------|   |        |    |-----------------|   |
    *    |--------------------------|        |--------------------------|
    *                 |                                    |
    *      ------------                                    |
    *      |                                               |
    *    0xFFFA1                                           |
    *    |---|---|---|---|---|---|---|---|---|---|---| ... |
    *    | I | v | a | n | o | v |   | I | v | a | n | ... |
    *    |---|---|---|---|---|---|---|---|---|---|---| ... |
    *                                                      |
    *      -------------------------------------------------
    *      |
    *    0xFFFC5
    *    |---|---|---|---|---|---|---|---|---|---|---| ...
    *    | I | v | a | n | o | v |   | I | v | a | n | ...
    *    |---|---|---|---|---|---|---|---|---|---|---| ...
    *    
    * В куче у нас теперь две строки "Ivanov Ivan Ivanovich" и оригинал с копией
    * каждый хранят указатель на свою собственную строку в куче.
    * 
    * Копия изменит свою строку на "another fio", а оригинал останется нетронутым.
    * 
    *     *                 good                             student
    *    |--------------------------|        |--------------------------|
    *    |    |-----------------|   |        |    |-----------------|   |
    *    |    |  fio = 0xFFFA2  |   |        |    |  fio = 0xFFFC5  |   |
    *    |    |-----------------|   |        |    |-----------------|   |
    *    |--------------------------|        |--------------------------|
    *                 |                                    |
    *      ------------                                    |
    *      |                                               |
    *    0xFFFA1                                           |
    *    |---|---|---|---|---|---|---|---|---|---|---| ... |
    *    | I | v | a | n | o | v |   | I | v | a | n | ... |
    *    |---|---|---|---|---|---|---|---|---|---|---| ... |
    *                                                      |
    *      -------------------------------------------------
    *      |
    *    0xFFFC5
    *    |---|---|---|---|---|---|---|---|---|---|---|
    *    | a | n | o | t | h | e | r |   | f | i | o |
    *    |---|---|---|---|---|---|---|---|---|---|---|
    *    
    * И все теперь будет хорошо.
    */

   /*
    * Итак.
    * 
    * Конструктор копирования нужен для корректного копирования сложных объектов, 
    * которые не будут корректно скопированы побайтово. В частности, это ВСЕГДА относится
    * к объектам, которые содержат любые динамические данные.
    * 
    * Если в объекте есть поле типа указатель, то такому объекту обязательно нужен конструктор
    * копирования, чтобы избежать таких коллизий.
    * 
    * Конструктор копирования вызывается в 3 случаях:
    * 1. передача объекта по значению
    * 2. возврат объекта по значению
    * 3. инициализация объекта путем присваивания другого объекта
    * Например, вот так:
    * 
    * Student st2 = good;
    * 
    * При такой операции тоже будет вызван конструктор копирования.
    * 
    * А вот тут:
    * 
    * Student st2("Petrov");
    * st2 = good;
    * 
    * Тут конструктор копирования вызван не будет. Потому что это не инициализация объекта,
    * а уже обычный вызов оператора =. Если вы хотите, чтобы такая операция срабатывала, то
    * нужно перегружать оператор = (который между прочим не обязательно должен принимать
    * параметром объект того же типа данных, вы можете сделать присваивание и алгоритм
    * работы с любым объектом ^_^ ).
    */

    void main()
    {
       StudentDummy st("Ivanov Ivan Ivanovich");
       func(st);
       cout << "StudentDummy fio = " << st.getFio() << endl;

       Student good("Ivanov Ivan Ivanovich");
       func(good);
       cout << "Student fio = " << good.getFio() << endl;

       Student st2 = good;

      /*
       * В конце программы будет ошибка. Вызвана она будет деструктором
       * класса StudentDummy. Как вы помните внутри func уже было высвобождение
       * памяти по указателю fio из объекта st. А при завершении программы
       * вызовется деструктор объекта, в котором будет попытка снова высвободить
       * эту же память. Естественно будет ошибка, потому что память-то уже освобождена.
       *  
       * В общем, не пугайтесь ошибки. Так и задумано.
       */
    }
}