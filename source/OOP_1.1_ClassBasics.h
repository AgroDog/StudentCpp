// Рассматриваемые темы:
// Что такое класс, области видимости, инкапсуляция

#pragma once

#include <iostream>
using namespace std;

namespace ClassBasics
{
	// В языке Си были только структуры. Использовались они как "коробки" с информацией.
	// С С++ появились классы. В чем отличие структуры от класса?

	// Глобально - НИ В ЧЕМ.
	// Единственное отличие:
	// В структуре все члены доступны для использования по умолчанию, пока не заявлено обратное
	// В классе все члены недоступны для использования никому вне этого класса, пока не заявлено обратное.
	
	// Сначала рассмотрим пример структур

	struct Plant
	{
		// по умолчанию в структуре все члены доступны
		// извне структуры, т.е. они ПУБЛИЧНЫЕ
		
		int age; // публичное поле
	private:// можно создать ПРИВАТНЫЕ члены структуры
			// такие члены будут доступны только внутри самой структуры
		
		int rootCount;	// вряд ли кому-то кроме самой структуры "растение"
						// интересно знать кол-во корней у растения 
	};

	void Func1()
	{
		Plant p;
		p.age = 10;			// мы можем легко получить доступ до публичного поля
		// p.rootCount = 4;	// а вот с приватным так не получится - будет ошибка доступа
	}

	//=======================================================================================================

	// Ситуация с классами обратная:

	class Table
	{
		// по умолчанию в классе все члены недоступны
		// извне класса, т.е. они ПРИВАТНЫЕ

		int humidity;	// параметр влажности будет скрыт для всех,
						// кроме самого класса
	public:	// если нужно дать доступ до какого-то члена класса,
			// то их помечают ПУБЛИЧНЫМИ

		int legCount; // кол-во ножек у стола будет доступно всем
	};

	void Func2()
	{
		Table t;
		// t.humidity = 90;	// влажность - приватное поле
							// у нас нет до него доступа
		t.legCount = 3;		// а вот кол-во ножек - публичное поле
	}

	//=======================================================================================================

	// Зачем нужны публичные и приватные поля?
	// (Кстати, есть еще модификатор protected, но о нем немного позже)

	// Считается, что вне класса находится жестокий и злой мир,
	// а класс - маленький и беззащитный.
	// Чтобы защитить свой нежный внутренний мир, класс прячет от внешнего мира
	// все свои "потроха", чтобы кто-то случайно или намеренно не сломал
	// информацию внутри класса.

	// Такой механизм называется ИНКАПСУЛЯЦИЕЙ
	// Инкапсуляция - сокрытие сложности и внутренней структуры класса.

	// Если серьезно, то класс представляется в виде "черного ящика":
	// какой алгоритм скрыт в нем, как класс работает, какие поля в нем есть - 
	// недопустимо знать пользователю, а тем более иметь возможость изменять
	// информацию в классе напрямую.

	// Все это делается из рассчета обспечения безопасности.

	// По принципу инкапсуляции принято все поля делать приватными,
	// а доступ к полям организовывать с помощью методов.

	class Server
	{
		short ipAddress[4];

	public:

		// Метод, который позволяет задать значение поля, называют
		// сеттером (от англ. setter).
		void setIpAddress(short array[4])
		{
			// Внутри сеттера часто помещают проверки на корректность данных
			for(int i = 0; i < 4; i++)
				// проверяем, чтобы все части ip адреса лежали в диапазоне от 1 до 255
				if (array[i] < 1 || array[i] > 255)
				{
					cout << "IP адрес некорректен!" << endl;
					return;
				}

			// Если адрес корректен, то сохраняем его
			for (int i = 0; i < 4; i++)
				ipAddress[i] = array[i];
		}

		// Метод, который позволяет получить значение поля, называют
		// геттером (от англ. getter).
		short* getIpAddress()
		{
			return ipAddress;
		}
	};

	//=======================================================================================================

	// Наследование

	//=======================================================================================================

	// Многие ошибочно полагают, что отлииче структуры от класса в том, что
	// в классе есть методы, а в структуре - нет или что в структуры не поддерживают наследование.
	// Но это ошибка.

	struct Animal
	{
		char* name;
		
		Animal()
		{
			cout << "Я родился!" << endl;
			chipId = 4;

			name = new char[8]{ 'C', 'h', 'i', 'm', 'a', 'e', 'r', 'a' };
		}

		~Animal()
		{
			cout << ":'(" << endl;
		}

	private: // все поля объявленные ниже будут недоступны всем, кроме самого класса
		int chipId; // номер чипа у животного
	};

	struct Dog : Animal
	{
		Dog()
		{
			cout << "Щеночек!" << endl;
			cout << "Дайте щеночку имя: ";
			char* buff = new char[255];
			cin >> buff;

			name = new char[strlen(buff)];
			strcpy(name, buff);

			delete[] buff;

			// chipId = 12; // эта строчка вызывает ошибку, 
							// потому что поле chipId недоступно для использования 
							// из-за модификатора доступа private в родительской структуре Animal
		}

		void Bark()
		{
			cout << "Гав!" << endl;
		}
	};

	void Func3()
	{
		Dog dog;
		dog.Bark();

		cout << dog.name << endl;
		//		cout << dog.chipId << endl; // эта строчка вызывает ошибку, 
		// потому что поле chipId недоступно для использования 
		// из-за модификатора доступа private в родительской структуре Animal
	}


	void main()
	{
		Func1();
		Func2();
		Func3();
	}

	// Итог:
	// Классы - это следующая ступень развития структур, чтобы следовать всем требованиям ООП.
	// На данный момент структуры существуют в том числе для обеспечения обратной
	// совместимости с языком Си.

	// Среди разработчиков принято следующее соглашение:
	// если для хранения информации требуется придерживаться принципов ООП (инкапсуляции, наследования и т.д.),
	// то используются классы.
	// 
	// если же требуется лишь хранение информации, причем соблюдение инкапсуляции необязательно,
	// то используются структуры.

	// Но т.к. если программа пишется с использование объектно-ориентированного подхода,
	// то чаще требуется полное соблюдение приципов ООП и структуры практически не используются.
	// Поэтому зачастую структуры считаются просто устаревшим этапом развития классов.

	// NB!
	// У структур могут быть методы!
	// У структуры может быть конструктор и деструктор!
	// Структуры можно наследовать!
}