// Рассматриваемые темы:
// Структура практические ничем не отличается от класса.
// Не верите? Сейчас докажу

#pragma once

#include <iostream>
using namespace std;

namespace StructVsClass
{
    // В языке Си были только структуры. В С++ появились классы. В чем отличие структуры от класса?
    
    // Глобально - НИ В ЧЕМ.
    // Единственное отличие:
    // В структуре все члены доступны для использования по умолчанию, пока не заявлено обратное
    // В классе все члены недоступны для использования никому вне этого класса, пока не заявлено обратное.

    // Сначала рассмотрим пример структур

    struct Plant
    {
        // по умолчанию в структуре все члены доступны
        // извне структуры, т.е. они ПУБЛИЧНЫЕ

        int age; // публичное поле
    private:// можно создать ПРИВАТНЫЕ члены структуры
            // такие члены будут доступны только внутри самой структуры

        int rootCount;	// вряд ли кому-то кроме самой структуры "растение"
                        // интересно знать кол-во корней у растения 
    };

    // Ситуация с классами обратная:

    class Table
    {
        // по умолчанию в классе все члены недоступны
        // извне класса, т.е. они ПРИВАТНЫЕ

        int humidity;	// параметр влажности будет скрыт для всех,
                        // кроме самого класса
    public:	// если нужно дать доступ до какого-то члена класса,
            // то их помечают ПУБЛИЧНЫМИ

        int legCount; // кол-во ножек у стола будет доступно всем
    };

    // Многие ошибочно полагают, что отлииче структуры от класса в том, что
    // в классе есть методы, а в структуре - нет или что в структуры не поддерживают наследование.
    // Но это ошибка.

    struct Animal
    {
        char* name;

        // У структуры может быть конструктор
        Animal()
        {
            cout << "Я родился!" << endl;
            chipId = 4;

            name = new char[8]{ 'C', 'h', 'i', 'm', 'a', 'e', 'r', 'a' };
        }

        // Деструктор тоже может быть
        ~Animal()
        {
            cout << ":'(" << endl;
        }

        // Модификаторы доступа тоже могут быть разными

    private: // все поля объявленные ниже будут недоступны всем, кроме самого класса
        int chipId; // номер чипа у животного
    };

    // Наследование? Легко!
    struct Dog : Animal
    {
        Dog()
        {
            cout << "Щеночек!" << endl;
            cout << "Дайте щеночку имя: ";
            char* buff = new char[255];
            cin >> buff;

            name = new char[strlen(buff)];
            strcpy(name, buff);

            delete[] buff;

            // chipId = 12; // эта строчка вызывает ошибку, 
            // потому что поле chipId недоступно для использования 
            // из-за модификатора доступа private в родительской структуре Animal
        }

        void Bark()
        {
            cout << "Гав!" << endl;
        }
    };

    void main()
    {
        Dog dog;
        dog.Bark();

        cout << dog.name << endl;
        //		cout << dog.chipId << endl; // эта строчка вызывает ошибку, 
        // потому что поле chipId недоступно для использования 
        // из-за модификатора доступа private в родительской структуре Animal
    }

    // Итог:
    // Классы - это следующая ступень развития структур, чтобы следовать всем требованиям ООП.
    // На данный момент структуры существуют в том числе для обеспечения обратной
    // совместимости с языком Си.

    // Среди разработчиков принято следующее соглашение:
    // если для хранения информации требуется придерживаться принципов ООП (инкапсуляции, наследования и т.д.),
    // то используются классы.
    // 
    // если же требуется лишь хранение информации, причем соблюдение инкапсуляции необязательно,
    // то используются структуры.

    // Но т.к. если программа пишется с использование объектно-ориентированного подхода,
    // то чаще требуется полное соблюдение приципов ООП и структуры практически не используются.
    // Поэтому зачастую структуры считаются просто устаревшим этапом развития классов.

    // NB!
    // У структур могут быть методы!
    // У структуры может быть конструктор и деструктор!
    // Структуры можно наследовать!
}