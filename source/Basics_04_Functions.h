// Рассматриваемые темы:
// Функции

#pragma once

#include <iostream>
using namespace std;

namespace Functions
{
    // Функция - это именованный кусок кода, 
    // который можно вызывать для выполнения неограниченное кол-во раз
    // Основная задача ф-ций - сделать код более компактным и читаемым

    // Пример простейшей ф-ции
    int add(int a, int b) // <-- Заголовок ф-ции
    { // <-- Начало тела ф-ции

        // Тут может быть любой код, который нужно выполнить

        return a + b; // Возвращаем результат работы функции
    } // <-- Конец тела ф-ции

    // Заголовок ф-ции обязательно должен состоять из следующий элементов:
    
    // ТВЗ ИМЯ_ФУНКЦИИ(СПИСОК_ПАРАМЕТРОВ)

    // ТИП ВОЗВРАЩАЕМОГО ЗНАЧЕНИЯ (ТВЗ)
    // Это тип данных результата работы ф-ции. Именно результат останется в коде в месте вызова вашей ф-ции
    // Если ф-ция не будет иметь результат (просто что-то делает и все), тогда тип возвращаемого значения будет void - отсутствие типа
    
    // ИМЯ ФУНКЦИИ
    // всегда должно содержать глаголы и по имени ф-ции должно быть легко понятно, что она делает. 
    // Хорошие примеры имен ф-ций: readFromFile, writeToFile, getVectorLength, multiplyMatrix, add
    // Примеры плохих имен функций: func1, foo, boo, getResult, do, blablabla
    
    // СПИСОК ПАРАМЕТРОВ
    // Параметры перечисляются в ф-ции через запятую. Параметр - это локальная переменная для функции, а значит вы объявляете переменные.
    // Синтаксис будет соответствующий. int param1, double param2 и т.д.

    // Еще немного примеров ф-ций:

    void writeToFile(char* str)
    {
        // ...
    }

    double devide(int a, double b, float c)
    {
        return a / b / c;

        cout << "^_^"; // Этот код уже не будет выполнен
                       // После команды return ф-ция возвращает результат своей работы и завершает выполнение сразу
    }

    void consoleRead(char* buff, int num)
    {
        cin.getline(buff, num);
    }
    
    int main() 
    {
        double a = devide(10, 3.7, 1.2);
        // ^^^
        // Что будет происходить: 
        // 1. Вызовется ф-ция, параметры (локальные переменные ф-ции) проинициализируются соответствующими значениями (a = 10, b = 3.7, c = 1.2)
        // Обратите внимание, что переменная a в ф-ции main и переменная a - в ф-ции devide - разные локальные переменные!
        // ВНИМАНИЕ!!! Каждая существует только внутри своего блока кода. И они никак не перемекаются, это разные ячейки в памяти.
        // 2. Ф-ция devide делает свое дело (причем, что она делает нас в ф-ции main вооще не волнует - это личное дело самой ф-ции)
        // 3. Как ф-ция выполнится, вместе всей конструкции "devide(10, 3.7, 1.2)" подставится итоговый результат работы ф-ции.
        // Будет что-то вроде
        // double a = результат;

        // И вызывать функцию мы можем до посинения:
        
        while (a > 0)
        {
            cout << a << endl;
            int p1; double p2; float p3;
            cin >> p1 >> p2 >> p3;
            a = devide(p1, p2, p3);
        }

        return 0;
    }

    // А теперь рассмотрим, когда функции каскадно вызывают друг друга

    void ChildFunction()
    {
        cout << "ChildFunction called" << endl;
    }

    void ParentFunction()
    {
        cout << "ParentFunction called" << endl;
        // LastFunction(); // <-- Попробуйте раскомментировать эту строчку

        // У вас будет ошибка, смысл которой сводится к тому, что компилятор не знает такую ф-цию LastFunction
        // Кажется, что это бред, потому что вон же она чуть ниже, однако это не бред:
        // компилятор С++ работает сверху вниз - все, что используется должно быть объявлено выше того момента, когда вы это используете.
        // Поэтому компилятор действительно на момент вызова ф-ции LastFunction ее еще не встретил и не знает, что это такое и как себя с ней вести.

        // Думаете проблема решается просто? Нужно просто перенести LastFunction повыше? Ну попробуйте
        // И увидите, что тут специально использовано несколько перекрестных ф-ций, которые используются друг другом.
        // В лучшем случае вам придется долго играть в пятнашки, чтобы правильно разместить перекрестные ф-ции, и чтобы они "видели" друг друга.
        // Но программисты люди ленивые - играть в пятнашки слишком долго и неэффективно

        // Пробелма решается с использованием "прототипов" функций (см. ниже)
    }

    void SemiFunction()
    {
        cout << "SemiFunction called" << endl;

        ParentFunction();
    }

    void LastFunction()
    {
        cout << "LastFunction called" << endl;

        SemiFunction();
    }

    // ИСПОЛЬЗОВАНИЕ ПРОТОТИПОВ

    void AnotherChildFunction(); // Это называется прототипов ф-ции. Прототип - синтаксическая запись заголовка ф-ции без тела
    void AnotherParentFunction(); // После заголовка функции сразу же идет ";" - блок кода ф-ции не начинается, его просто нет
    void AnotherSemiFunction(); // Прототип ф-ции дает понять компилятору, что где-то там когда-нибудь обязательно встретиться
    void AnotherLastFunction(); // ф-ция в своем нормальном виде, но вот прямо сейчас всю ф-цию мы тебе не покажем, но имей в виде, что она есть.

                                // После такого "диалога" компилятор успокаивается, он нам верит до поры до времени и если встретит использования ф-ции,
                                // описанной с помощью прототипа, он это проглотит и уже не будет пугаться "Ой, а чёй-то такое?!?!"
                                // Но имейте в виду, если есть прототип ф-ции, но до конца модуля самой ф-ции не встретится, то компилятор все равно поднимет панику:
                                // "Ты мне обещал! Обещал, что покажешь всю ф-цию, а ее нет!!!! :'''((("

    void AnotherChildFunction()
    {
        cout << "ChildFunction called" << endl;
    }

    void AnotherParentFunction()
    {
        cout << "ParentFunction called" << endl;
        AnotherLastFunction();
    }

    void AnotherSemiFunction()
    {
        cout << "SemiFunction called" << endl;

        ParentFunction();
    }

    void AnotherLastFunction()
    {
        cout << "LastFunction called" << endl;

        SemiFunction();
    }
}