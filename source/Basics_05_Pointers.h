// Рассматриваемые темы:
// Указатели

#pragma once

#include <iostream>
using namespace std;

namespace Pointers
{
   int main()
   {
      /* При использовании локальных переменных управление памятью берет на себя сама программа. 
       * Когда завершится блок кода - локальная переменная будет вытолкнута из стека, 
       * и таким образом ее память освободится. 
       * 
       * Однако размер стека сильно ограничен. К тому же мы не имеем никакого управления над
       * переменными внутри стека. А зачастую программисту требуется тонкий контроль над памятью.
       * 
       * В этом случае используется динамическая область памяти - так называемая, куча (heap).
       * Куча - это область памяти, управление которой полностью лежит на программисте,
       * программа уже не имеет контроля над этой областью памяти.
       * 
       * NB: данное высказывание работают не полностью в более высокоуровневых языка,
       * таких как C# или Java, потому что ни работают в обертки собственной виртуальной машины и
       * имеют ряд утилит для управления памятью кучи, например, "сборщик мусора".
       * 
       * Для управления памятью в куче был введен тип данных - УКАЗАТЕЛЬ.
       * 
       * Указатель - это переменная, которая хранит адрес ячейки памяти в куче.
       * 
       * Объявляется указатель по следующему шаблону:
       * 
       * ТИП_ДАННЫХ* ИМЯ_ПЕРЕМЕННОЙ;
       * 
       * NB: здесь тип_данных - это тип данных, которые хранятся по адресу в указателе.
      */

      int* ptr1; // Это указатель
      float *ptr2; // И это указатель
      double *ptr3; // Это тоже указатель
      char* ptr4; // И даже это указатель

      // ^^^ У всех этих переменных тип данных - указатель
      // Не int, float, double или какой-то еще, а именно УКАЗАТЕЛЬ

      int num1; // Это переменная типа данных int
      int* anotherPtr1; // А это указатель!
      float num2; // Не указатель
      double num3; // Тоже не указатель
      char *num4; // А вот это указатель

      // NB: синтаксически компилятор позволяет объвлять указатель двумя способами:
      int* ptr5;
      // или
      int *ptr6; // <-- по нотации С++ правильно писать именно так
      // Синтаксически разработчики компилятора сделали вот такую подлянку:
      int* a1, a2; // Думаете здесь через запятую объявлено 2 переменных типа данных указатель?
      // А вот ФИГ ВАМ!
      // В случае выше объявлен ОДИН указатель и ОДНА переменная int
      // Чтобы через запятую получить два указателя, нужно писать так:
      int* a3, *a4; // <-- Т.е. обязательно добавлять звездочку перед именем самой переменной
      // Без этого оператор запятая не сможет правильно разобрать конструкцию.

      // И вот из-за такой маленькой особенности, чтобы не забывать об этой синтаксической особенности
      // исторически стали пристыковыввать звездочку к имени переменной. Вот так:
      int *a6;

      // Но у многих начинающих С++ программистов из-за этого начинаются проблемы 
      // с идентификацией типа данных переменных
      int *some_variable; // <-- На вопрос "Какой это тип данных?"
      // Часто дают ответ - "int естественно". Видимо символ * - это мухи натоптали на экране.

      // Поэтому некоторые, чтобы не забывать об этом, стыкубт звездочку именно с типом данных
      int* another_variable;

      // Лично мне нравится писать именно так. Никто вас за это не осудит, но по стандарту
      // делается это наоборот.

            

      return 0;
   }
}