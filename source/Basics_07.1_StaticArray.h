// Рассматриваемые темы:
// Массив, статический массив

#pragma once
#include <iostream>
using namespace  std;

namespace StaticArray
{
   int main()
   {
      /*
       * Массив - это именнованная последовательность элементов в памяти.
       * Особенностью массива является, что элементы хранятся в памяти друг за другом
       * причем подряд.
       * 
       * Доступ до элементов идет по индексу элемента.
       * Индексация всегда начинается с нуля.
       * 
       *       0      1      2      3      4
       *    |------|------|------|------|------|
       *    |  12  |  60  |  25  |  5   |  19  |
       *    |------|------|------|------|------|
       *    
       * Это иллюстрация ячеек памяти массива на 5 элементов.
       * 
       * Массив может быть объявлен статически и динамически.
       * 1. При статическом объявлении память под массив выделяется в стеке,
       * массив является локальной переменной и будет уничтожен по правилам
       * локальных переменных.
       * 2. При динамическом объявлении память выделяется в куче программы - 
       * ее еще называют динамической памятью. Управление ею лежит полностью
       * на совести самого программиста. Доступ до массива осуществляется
       * через указатель.
       * 
       * Сейчас речь пойдет про СТАТИЧЕСКИЙ МАССИВ.
       * Объявить и проинициализировать такой массив можно следюущим образом:
       */

      int array1[5];
      /*
       * int - тип данных элементов массива
       * Это будет массив, хранящий целые числа
       * Тип данных элементов может быть любой
       * array1 - имя переменной. Вы сами его выбираете
       * [n], где n - кол-во элементов в массиве
       * Причем n должно быть константой так или иначе
      */

      int n = 10;
      const int m = 10;
      int array01[m];
      int array02[10];
      // int array03[n]; // А вот так не получится
      /*
       * Не получится, потому что компилятор не может быть на момент исполнения
       * предсказать, какое число будет вместо n. А значит и выделить память в стеке
       * небезопасно, а значит... Не пошел бы программист лесом. :)
      */

      // Обращение к ячейке памяти происходит с помощью оператора []
      // Как параметр этот параметр принимает
      // СМЕЩЕНИЕ относительно начала массива
      array1[0] = 12;
      array1[1] = 60;
      array1[2] = 25;
      array1[3] = 5;
      array1[4] = 19;

      /*
       * Догадливые уже могли понять:
       * имя массива является адресом начала массива в памяти
       * 
       *       0      1      2      3      4
       *    |------|------|------|------|------|
       *    |  12  |  60  |  25  |  5   |  19  |
       *    |------|------|------|------|------|
       *       ^
       *       |
       *     array1
       *     
       * И переменная array1 хранит именно АДРЕС самой первой ячейки массива
       * (см. раздел указатели, в котором пояснено, что, например, 1 число типа int
       * занимает не 1 ячейку памяти, а 4, потому что 1 ячейка = 1 байт)
       * 
       *          Байты 0 элемента            Байты 1 элемента            .....
       *    |---------------------------|---------------------------|---- и т.д.    
       *    |                           |                           |
       *    |------|------|------|------|------|------|------|------|
       *    |  хх  |  хх  |  хх  |  хх  |  хх  |  хх  |  хх  |  хх  |     ......
       *    |------|------|------|------|------|------|------|------|
       *       ^
       *       |
       *     array1
       * 
       * array1 - локальная переменная. А значит хранится в стеке.
       * array1 хранит адрес ячейки в стеке.
       */

      cout << "array1 = " << array1 << endl;

      // Естественно, что массивом можно управлять и с помощью цикла
      for (int i = 0; i < 5; i++) cout << "array1[" << i << "] = " << array1[i] << endl;

      // Если элементы массива извесстны заранее, то объявление и инициализацию можно объединить
      float array2[3] = { 1.2, 3.6, 20.5 };

      /*
       * Как и любая локальная переменная статический массив будет уничтожен
       * по завершению блока кода, в котором был объявлен.
       */

      return 0;
   }
}
