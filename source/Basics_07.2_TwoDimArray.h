// Рассматриваемые темы:
// Двумерный массив

#pragma once
#include <iostream>
using namespace std;

namespace TwoDimArray
{
   void main()
   {
      /*
       * В некоторых задачах требуется хранить набор данных для набора данных.
       * Например, допустим, нужно хранить оценки студентов по двум дисциплинам.
       * Всего студентов 3 человек.
       * 
       * 3 человека и у каждого по 2 оценки.
       * 
       * Сохранить эту информацию можно 3 способами
       * 1. Несколько небольших массивов
       * 2. Один большой массив
       * 3. Двумерный массив
       * 
       * Рассмотрим каждый способ по порядку:
       * 
       * 1. Несколько небольших массивов
       * Для каждого студента будем создавать свой собственный массив на 2 оценки
       */

      int arrayStudent1[2];
      // Первый студент пусть будет отличником
      arrayStudent1[0] = 5;
      arrayStudent1[1] = 5;
      int arrayStudent2[2];
      // Второй - двоечником
      arrayStudent2[2] = 2;
      arrayStudent2[3] = 2;
      int arrayStudent3[2];
      // Третий - перебивающийся
      arrayStudent3[4] = 4;
      arrayStudent3[5] = 3;

      /*
       * Вроде, выглядит неплохо. Легко читается, код понятен. Тогда что не так?
       * Универсальность. Допустим, мы не знаем до начала программы, сколько будет студентов.
       * Пользователь только после запуска программы введет число студентов в группе.
       * Сколько тогда создать переменных? 10? 50? 100? 1000?
       * И что? Все их объявлять? А как обращаться к такому непонятному числу переменных?
       * 
       * В общем, это не то чтобы невозможно. Но такие извращения в такой задаче излишни.
       * Все должно быть намного проще.
       */

      /*
       * 2. Один массив для всех данных
       * 
       * Чтобы сохранить оценки для 3 человек понадобится 6 ячеек памяти
       * Ячейки 0 и 1 будут оценками для студента 0 
       * (индексация приведена с 0, как в массиве)
       * Ячейки 2 и 3 - оценки 1 студента
       * Ячейки 4 и 5 - оценки 2 студента
       */

      int array1[6];
      
      array1[0] = 5;
      array1[1] = 5;
      
      array1[2] = 2;
      array1[3] = 2;

      array1[4] = 4;
      array1[5] = 3;

      /*
       * Итак у нас есть 3 студента у каждого по 2 оценки. Все они хранятся в одном массиве.
       * Мы решили проблему с универсальностью (допустим, мы как-то обошли ограничение,
       * что чиисло элеементов в массиве должно быть только константой).
       * 
       *  Тогда, допустим, что мы можем создавать массив для n студентов и m дисциплин.
       *  Размер массива для хранения всего этого дела будет равен n * m
       *  
       * Но как обратиться, скажем, к оценке по первой дисциплине у второго студента?
       * Если индексация идет с 0, то нам нужен студент с индексом 1 и дисциплина с индексом 0
       * 
       * Если ппосмотреть на инициализацию массива выше, то нужная оценка лежит по индексу - 2
       * 
       * Далее несложно вывести формулу индекса нужной оценки в массиве: 
       * i * m + j = 1 * 2 + 0 = 2
       * где i - индекс искомого студента, а j - индекс нужной дисциплины
       * 
       * Такую формулу можно запрограммировать. Пользователь вводит номер студента, номер дисциплины,
       * а программа, рассчитав формулу, выдаст нужную оценку.
       * 
       * Профит.
       */

      /*
       * Но опять же программисты дюже ленивые существа. Каждый раз делать умножение и сложение
       * вручную, только чтобы узнать индекс оценки... Нет, не наш способ.
       * 
       * Поэтому во всех языках программирования есть понятие многомерных массивов.
       * В данном случае нам будет достаточно двумерного массива.
       * 
       * 3. Двумерный массив
       */

      int array[3][2]; // 3 студента по 2-м дисциплинам
      // Оценки 0 студента
      array[0][0] = 5; // 0 дисциплина
      array[0][1] = 5; // 1 дисциплина
      // Оценки 1 студента
      array[1][0] = 2; // 0 дисциплина
      array[1][1] = 2; // 1 дисциплина
      // Оценки 2 студента
      array[2][0] = 4; // 0 дисциплина
      array[2][1] = 3; // 1 дисциплина

      /*
       * Какое же преимущество дает двумерный массив? 
       * По сравнению со втором способом (один массив) мы просто получили более удобную индексацию.
       * Да, не так много. Но читаемость кода увеличилась, теперь мы прямо во время запроса
       * оценки видим, какой индекс студента и дисциплины запрашивается.
       * Плюс нам не нужно производить вычислений по формуле.
       * 
       * Как же это работает.
       * 
       * На самом деле запись двумерного массива - это лишь синтаксический "сахар" для программиста.
       * В памяти "двумерный" массив программой размещается в памяти, как один "длинный" маассив,
       * как мы сами руками делали во втором способе.
       * 
       * Но рассчет всех формул берет на себя программа за нас.
       * 
       * int array[3][2];
       * преобразуется компилятором в строчкуу
       * int array[3 * 2];
       * 
       * А строчка
       * array[i][j];
       * преобразуется в
       * array[i * m + j];
       * 
       * На самом деле, как вы помните, даже оператор [] - это тоже сахар и на самом деле
       * это выглядит еще немного по-другому:
       * 
       * *(array + i * m + j);
       * 
       * и это истинная запись такой простой команды:
       * 
       * array[i][j];
       */

      /*
       * Ну хорошо, с использованием двумерных массивов разобрались, но как же они хранятся в памяти.
       * Ответ на этот вопрос уже звучал: двумерный массив преобразуется компилятором 
       * в длинный двумерный массив. А значит массив 
       * 
       * int array[3][2];
       * 
       * в памяти выглядит так:
       * 
       *       0      1      2      3      4      5
       *    |------|------|------|------|------|------|
       *    |  5   |  5   |  2   |  2   |  4   |  3   |
       *    |------|------|------|------|------|------|
       *    ^             ^             ^             ^
       *    |-------------|-------------|-------------|
       *     оценки 1 ст.   оценки 2 ст.  оценки 3 ст.
       *     
       * Еще раз: 
       * 
       * Массив любой размерности хранится в памяти ЛИНЕЙНО.
       * Память в принципе линейна. Ячейки идут друг за другом. 
       * Перемещаться в памяти можно либо вперед, либо назад.
       * Никаких "верх", "вниз" в памяти быть не может по определению.
       * 
       * Да, двумерный массив по смыслу и использованию похож на матрицу или таблицу.
       * Но 
       * 
       * НИКАКИХ ТАБЛИЦ В ПАМЯТИ БЫТЬ НЕ МОЖЕТ. 
       * 
       * Память линейна. Все данные в массивах хранятся подряд.
       */
   }
}