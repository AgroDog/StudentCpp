// Рассматриваемые темы:
// Жизненный цикл объекта, конструктор, деструктор

#pragma once

#include <iostream>
#include <fstream>
#include <cstdlib>
#include <string.h>
#include <conio.h>

using namespace std;

namespace ClassLifeCycle
{
    // Принципы ООП старались как можно более приблизить реальную жизнь к программным моделям.
    // Поэтому у объектов есть так называемый "жизненный цикл".
    // Объекты рождаются, живут, выполняют свою роль, а затем умирают.

    // Когда объект "рождается" вызывается специальный метод класса - конструктор.
    // Когда объект "умирает" вызывается специальный метод класса - деструктор.

    class Human
    {
        int height;
        int weight;

    public:
        // Конструктор - метод класса, который имеет такое же имя, как и сам класс
        // Конструктор НЕ ИМЕЕТ возвращаемого значения, потому что результата работы
        // у конструктора - нет. Он что-то делает и все.
        Human()
        {
            cout << "Я родился! И ничего о себе не знаю." << endl;
        }

        // Конструктор можно перегружать 
        // (может существовать несколько конструкторов с разными параметрами)
        Human(int h)
        {
            height = h;
            cout << "Я родился! И я знаю свой рост! " << height << " см" << endl;
        }

        // Если лениво писать внутри конструктора
        // height = h;
        // weight = w;
        // то можно использовать краткую версию инициализатора
        Human(int h, int w) : height(h), weight(w) // <-- вот она, после ":"
        {
            cout << "Я родился! И я знаю свой рост и вес! " << height << " см " << weight << " кг" << endl;
        }

        // Деструктор - метод класса, который имеет такое же имя, как и сам класс с тильдой в начале
        // Деструктор также НЕ ИМЕЕТ возвращаемого значения
        ~Human()
        {
            cout << "RIP" << endl;
        }
    };

    void main()
    {
         Human* temp;
         { // <-- начало блока кода
            Human h1;
            Human h2(54);
            
            Human* h4 = new Human(50); // Это динамический объект
            temp = h4; // Сохраним адрес, чтобы не потерять
         } // <-- конец блока кода (все локальные переменные будут удалены)

         // Когда блок кода завершился, то переменные h1 и h2 были уничтожены,
         // а перед тем как их "убили" вызвался деструктор
         // Но удалятся только статические объекты. Обратите внимание, 
         // что надпись RIP на данном этапе появилась только 2 раза.

         // Создаем новый объект. Он будет существовать до конца программы
         Human h3(48, 3);

         // А вот сейчас мы "убьем" динамический объект
         delete temp; // Сейчас вызовется деструктор

         // ИТОГ:

         // Конструктор вызывается сразу после создания объекта. 
         // Делать конструктор может ВСЕ ЧТО УГОДНО.
         // Но чаще всего его используют для начальной инициализации полей класса.

         // Деструктор вызывается непосредственно перед удалением объекта. 
         // Делать деструктор может ВСЕ ЧТО УГОДНО.
         // Но чаще всего его используют для высвобождения динамической памяти внутри класса.

       // А теперь вернемся к вопросу важности delete и delete[]
       // Наконец-то мы можем "почуствовать" в чем же важность этой разницы

        Human* array1 = new Human[5]; // 5 раз вызвался конструктор
        delete[] array1; // 5 раз вызвался деструктор

       // А теперь сделаем неправильно
        Human* array2 = new Human[5];
        delete array2; // Деструктор вызовется 1 раз, а затем... 

       /*
        * А затем в лучшем случае будет ошибка, в худшем - непредвиденное поведение.
        * 
        * Почему ошибка это лучший случай? Потому что лучше знать, в каком месте в коде
        * вы накосячили, чем программа проскочит это место, а потом что-то пойдет не так
        * в совершенно неожиданном месте.
        * 
        * Итак, почему же деструктор вызовется только один раз?
        * 
        * Когда мы выделяем память под объект или массив с помощью new и new[] соответственно
        * на самом деле компилятору без разницы под массив выделяется память или нет,
        * при выделении память просто вычисляется кол-во байт для резервирования,
        * находится участок подходящего размера, он помечается как занятый, а перед
        * этим участком записываются метаданные - размер занятого участка. Все.
        * 
        * Разницы между new и new[] с точки зрения памяти никакой.
        * 
        * Но допустим, у нас массив не простых типов данных, а объектов.
        * И у этих объектов есть кастомный деструктор, который нужно запускать.
        * 
        * Если вызвать освобождение памяти с помощью delete, то память-то высвободится вся,
        * потому что ее размер записан в метаданных, но delete будет считать, что объект-то
        * в памяти всего один и лежит там, где указатель ему сказал, а значит деструктор
        * вызывать нужно только один раз!
        * 
        * Но если деструктор вызвался только у одного объекта, за остальными остался "мусор"
        * в памяти... В общем, предсказать что произойдет дальше в программе нельзя.
        * Взорваться не взорвется, но ничем хорошим тоже вряд ли закончится.
        * 
        * Ошибка же может и не всплыть. Но если всплывет, то программа просто увидит повреждение
        * кучи. Повезло. А может и не повезти.
        * 
        * Если же вызывать освобождение через delete[], то delete[] проанализирует, сколько
        * объектов в массиве примерно так:
        * 
        * SIZE / sizeof(T)
        * 
        * где SIZE - это размер всей зарезервированной памяти под массив
        * T - тип данных объекта, который хранится в массиве, в нашем примере это был Human
        * 
        * Узнав, что там лежит больше 1 объекта, delete[] уже начинает стучаться к каждому
        * и вызывать деструктор.
        * 
        * Теперь вам понятно, когда перепутать delete и delete[] может быть опасно для жизни.
        * 
        * Всегда используйте правильный вариант команды освобождения памяти.
        */
    }
}